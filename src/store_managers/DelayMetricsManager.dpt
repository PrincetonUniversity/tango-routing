include "../Types.dpt"

// Keep track of delay metrics
module DelayMetricsManager : {
    global type t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>>;
    constr t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> create ();

   /*
    * Updates the delay from the incoming Tango packets timestamp
    * 
    * PARAMETERS
    * ----------
    * self (t): self
    * timestamp (int): sequence number to index into pads
    * path_id (int<<path_id_sz>>): the path on which the packet came
    * 
    * RETURNS
    * -------
    * metrics (DelayMetrics_t<<delay_sum_sz, delay_count_sz>>): the calculated metrics
    */
    fun DelayMetrics_t<<'delay_sum_sz, 'delay_count_sz>> update_delay (
        t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> self,
        int timestamp,
        int<<'path_id_sz>> path_id
    ) [start <= self; end self];

   /*
    * Gets the delay metrics for the path
    * 
    * PARAMETERS
    * ----------
    * self (t): self
    * path_id (int<<path_id_sz>>): the path of interest
    * 
    * RETURNS
    * -------
    * metrics (DelayMetrics_t<<delay_sum_sz, delay_count_sz>>): the calculated metrics
    */
    fun DelayMetrics_t<<'delay_sum_sz, 'delay_count_sz>> get_metrics (
        t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> self,
        int<<'path_id_sz>> path_id
    ) [start <= self; end self];

}
{
    type t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> = {
        Array.t<<'delay_sum_sz>> delay_sums;
        Counter.t<<'delay_count_sz>>[num_path_ids] delay_counts;
    }

    constr t create() = {
        delay_sums = Array.create(size_to_int(num_path_ids));
        delay_counts = [Counter.create(0) for x < num_path_ids];
    };

    fun DelayMetrics_t<<'delay_sum_sz, 'delay_count_sz>> update_delay (
        t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> self,
        int timestamp,
        int<<'path_id_sz>> path_id
    ) {
        printf("ERROR: `DelayMetricsManager.update_delay()` is *unimplemented*");
        return {
            delay_sum = 0;
            delay_count = 0;
        };
        /* TODO */
    }

    fun DelayMetrics_t<<'delay_sum_sz, 'delay_count_sz>> get_metrics (
        t<<'path_id_sz, 'delay_sum_sz, 'delay_count_sz, 'num_path_ids>> self,
        int<<'path_id_sz>> path_id
    ) {
        printf("ERROR: `DelayMetricsManager.get_metrics()` is *unimplemented*");
        return {
            delay_sum = 0;
            delay_count = 0;
        };
        /* TODO */
    }
}
