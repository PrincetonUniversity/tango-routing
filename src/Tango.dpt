include "Types.dpt"
include "TrafficClassMap.dpt"
include "store_managers/SequenceNumberManager.dpt"
include "store_managers/RouteManager.dpt"
include "store_managers/TangoHeaderManager.dpt"
include "store_managers/MetricSignatureManager.dpt"
include "store_managers/BookSignatureManager.dpt"
include "store_managers/DelayMetricsManager.dpt"
include "store_managers/LossMetricsManager.dpt"
include "store_managers/InvalidPacketManager.dpt"
include "store_managers/EncryptionManager.dpt"
include "store_managers/BestMetricsManager.dpt"

/* ================================================================================================================== *
 *                                                     EXTERNS                                                        *
 * ================================================================================================================== */

symbolic int out_peer_port;

/* ================================================================================================================== *
 *                                                   CONSTANTS                                                        *
 * ================================================================================================================== */

// Ethernet header for all outgoing Tango traffic
const EthernetHeader_t TANGO_ETH_HDR = {
    dest_mac = 0;
    src_mac = 0;
    ethertype = 0;
};

/* ================================================================================================================== *
 *                                                     GLOBALS                                                        *
 * ================================================================================================================== */

// Keep track of the traffic class to physical path ID mappings
global RouteManager.t route_manager = RouteManager.create();

// Static mapping of physical path IDs to Tango UDP Headers (Read-Only)
global TangoHeaderManager.t header_manager = TangoHeaderManager.create();

// Counter keeping track of tango sequence numbers w.r.t. outgoing flow packets
global SequenceNumberManager.t sequence_counters = SequenceNumberManager.create();

// Decrypt path updates using one-time pads
global EncryptionManager.t incoming_encryption_manager = EncryptionManager.create();

// Provide read access to precomputed timestamp + path ID signatures for validation
global MetricSignatureManager.t incoming_metric_signature_manager = MetricSignatureManager.create();

// Provide read access to precomputed 1-bit signatures derived from sequence numbers for validation
global BookSignatureManager.t incoming_book_signature_manager = BookSignatureManager.create();

// Provide read access to precomputed 1-bit signatures derived from sequence numbers
global BookSignatureManager.t outgoing_book_signature_manager = BookSignatureManager.create();

// Provide read access to precomputed timestamp + path ID signatures
global MetricSignatureManager.t outgoing_metric_signature_manager = MetricSignatureManager.create();

// Keep track of delay metrics of paths from peer
global DelayMetricsManager.t delay_metrics_manager = DelayMetricsManager.create();

// Keep track of loss metrics of paths from peer
global LossMetricsManager.t loss_metrics_manager = LossMetricsManager.create();

// Keep track of invlaid packets found
global InvalidPacketManager.t invalid_pkt_manager = InvalidPacketManager.create();

// Keep track of the most performant paths
global BestMetricsManager.t best_metrics_manager = BestMetricsManager.create();

// Encrypt path updates using one-time pads
global EncryptionManager.t outgoing_encryption_manager = EncryptionManager.create();

/* ================================================================================================================== *
 *                                                     EVENTS                                                         *
 * ================================================================================================================== */

/*
 * Event signifying application flow data packet to forward to peer Tango node.
 * 
 * PARAMETERS
 * ----------
 * eth_header (`EthernetHeader_t`): ethernet frame header
 * ip_header (`IPv4Header_t`): IPv4 header of incoming packet
 * five_tuple (`FiveTuple_t`): five-tuple describing flow
 *
 * GENERATES
 * ---------
 * incoming_tango_traffic: flow packet wrapped with tango data sent to peer node
 */
entry event forward_flow (EthernetHeader_t eth_header, IPv4Header_t ip_header, FiveTuple_t five_tuple);

/*
 * Incoming Tango data traffic from peer node.
 * 
 * PARAMETERS
 * ----------
 * tango_eth_header (EthernetHeader_t): tango tunnel ethernet frame header
 * tango_ip_header (IPv6Header_t): tango tunnel IPv6 header
 * tango_metrics_header (TangoHeader_t): tango metric data and signatures
 * encaped_eth_header (EthernetHeader_t): flow ethernet header tunneled through path
 * encaped_ip_header (IPv4Header_t): flow IPv4 header tunneled thrpugh path
 *
 * GENERATES
 * ---------
 * route_update: sometimes responds to peer that they should update route due to changed metrics
 * complete_forward: forwards the packet on to its final destination
 */
event incoming_tango_traffic ( // TODO: Compiler gave warning about unconditional and not 'exit'
    EthernetHeader_t tango_eth_header,
    IPv6Header_t tango_ip_header,
    TangoHeader_t tango_metrics_header,
    EthernetHeader_t encaped_eth_header,
    IPv4Header_t encaped_ip_header
); // TODO: Do we need constraints?

/*
 * Peer says to update a given route mapping for a traffic class
 * 
 * PARAMETERS
 * ----------
 * update (int<<64>>): encrypted version of the update
 */
event route_update (int<<64>> update);

/*
 * Forward the flow using tango to its final destination.
 * 
 * PARAMETERS
 * ----------
 * ethernet_header (EthernetHeader_t): ethernet header of original packet, to re-encapsulate
 * ip_header (IPv4Header_t): the full ip header of packet, to re-encapsulte
 */
exit event complete_forward (EthernetHeader_t ethernet_header, IPv4Header_t ip_header);

/* ================================================================================================================== *
 *                                                    HANDLERS                                                        *
 * ================================================================================================================== */

handle forward_flow (EthernetHeader_t eth_header, IPv4Header_t ip_header, FiveTuple_t five_tuple) {

    /* 1. Map flow to a specific physical route. */
    // -- Map flow to traffic class.
    int<<4>> traffic_class = map_flow_to_traffic_class(five_tuple);

    // -- Find route cooresponding to traffic class.
    int<<3>> path_id = RouteManager.get_path_id(route_manager, traffic_class);

    // -- Get physical path header to tunnel with.
    IPv6Header_t physcial_path_hdr = TangoHeaderManager.get_path_header(header_manager, path_id);


    /* 2. Increment and sign sequence number. */
    // -- Get updated sequence number
    int<<24>> seq_number = SequenceNumberManager.increment(sequence_counters, path_id);

    // -- Get signature corresponding to sequence number
    int<<1>> book_signature = BookSignatureManager.sign(outgoing_book_signature_manager, seq_number, path_id);


    /* 3. Record and sign path-specific timestamp. */
    // -- Get current time in milliseconds
    int timestamp = Sys.time(); // FIXME: Switch to 'ms'

    // -- Get precomputed path-specific signature
    int<<256>> ts_signature = MetricSignatureManager.sign(outgoing_metric_signature_manager, timestamp, path_id);


    /* 4. Encapsulate and forward packet. */
    TangoHeader_t tango_metrics_hdr = {
        path_id = path_id;
        timestamp = timestamp;
        signature = ts_signature;
        sequence_num = seq_number;
        book_signature = book_signature;
    };
     
    event forward_tango_pkt = incoming_tango_traffic (
        TANGO_ETH_HDR,
        physcial_path_hdr,
        tango_metrics_hdr,
        eth_header,
        ip_header
    );

    generate_port (out_peer_port, forward_tango_pkt);
}

handle incoming_tango_traffic (
    EthernetHeader_t tango_eth_header,
    IPv6Header_t tango_ip_header,
    TangoHeader_t tango_metrics_header,
    EthernetHeader_t encaped_eth_header,
    IPv4Header_t encaped_ip_header
) {
    printf("ERROR: hander `incoming_tango_traffic` is *unimplemented*");
    // TODO

    // 1. Validate signatures
    bool is_valid_seq_num = BookSignatureManager.verify(
        incoming_book_signature_manager,
        tango_metrics_header#sequence_num,
        tango_metrics_header#path_id,
        tango_metrics_header#book_signature
    );

    // 2. Update Metrics
    int time_now = Sys.time(); // NOTE: in nanoseconds

    auto tunneled = complete_forward (encaped_eth_header, encaped_ip_header);
    generate_port (out_peer_port, tunneled);

    auto update = route_update (12312);
    generate_port (out_peer_port, update);
}

handle route_update (int<<64>> update) {
    printf("ERROR: hander `route_update` is *unimplemented*");
    // TODO

}
