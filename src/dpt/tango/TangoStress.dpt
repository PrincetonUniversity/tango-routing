include "Time.dpt"
include "Types.dpt"
include "static_maps/TrafficClassMap.dpt"
include "static_maps/TunnelHeaderMap.dpt"
include "store_managers/SequenceNumberManager.dpt"
include "store_managers/cryptography/signatures/BookSignatureManager.dpt"
include "store_managers/cryptography/signatures/MetricSignatureManager.dpt"

/* ================================================================================================================== *
 *                                                     EXTERNS                                                        *
 * ================================================================================================================== */

// Port declarations
const int<<9>> OUT_PORT = 128;
const int<<9>> RECIRC_PORT = 196;

// Tango IPv6 Header
const IPv6Header_t TANGO_V6_HEADER = {
    version_cls_flow = 0;
    payload_len = 0;
    next_header = 0;
    hop_limit = 0;
    src_addr_lo = 0;
    src_addr_hi = 0;
    dest_addr_lo = 0;
    dest_addr_hi = 0;
};

// Tango UDP header to counter ECMP
const UDPHeader_t TANGO_UDP_HEADER = {
    source_port = 8080;
    destination_port = 8080;
    length = 0;
    checksum = 0;
};

/* ================================================================================================================== *
 *                                                     GLOBALS                                                        *
 * ================================================================================================================== */

// Counter keeping track of tango sequence numbers w.r.t. outgoing flow packets
global SequenceNumberManager.t sequence_counters = SequenceNumberManager.create();

// Provide read access to precomputed 1-bit signatures derived from sequence numbers
global BookSignatureManager.t outgoing_book_signature_manager = BookSignatureManager.create();

// Provide read access to precomputed timestamp + path ID signatures
global MetricSignatureManager.t outgoing_metric_signature_manager = MetricSignatureManager.create();

/* ================================================================================================================== *
 *                                                     EVENTS                                                         *
 * ================================================================================================================== */

/**
 * # Description
 * Application packet tunneled through system.
 * 
 * # Parameters
 * eth_header (`EthernetHeader_t`): ethernet frame header
 * ip_header (`IPv4Header_t`): IPv4 header of incoming packet
 * udp_header (`UDPHeader_t`): TCP header of incoming packet
 *
 * # Generates
 * incoming_tango_traffic: flow packet wrapped with tango data sent to peer node
 **/
entry event forward_flow (
    EthernetHeader_t eth_header,
    IPv4Header_t ip_header,
    UDPHeader_t udp_header
) [
    sequence_counters < outgoing_book_signature_manager;
    outgoing_book_signature_manager < outgoing_metric_signature_manager
];

/**
 * # Description
 * Incoming Tango data traffic from peer node.
 * 
 * # Parameters
 * tango_eth_header (EthernetHeader_t): tunneled ethernet frame header
 * tango_ip_header (IPv6Header_t): tango tunnel IPv6 header
 * tango_tango_udp_header (UDPHeader_t): udp header to counter ECMP
 * tango_metrics_header (TangoHeader_t): tango metric data and signatures
 * encaped_ip_header (IPv4Header_t): flow IPv4 header tunneled thrpugh path
 * encaped_udp_header (UDPHeader_t): tcp header of tunneled packet
 *
 * # Generates
 * request_route_update: sometimes responds to peer with route mapping update
 * complete_forward: forwards the packet on to its final destination
 **/
exit event incoming_tango_traffic (
    EthernetHeader_t tango_eth_header,
    IPv6Header_t tango_ip_header,
    UDPHeader_t tango_udp_header,
    TangoHeader_t tango_metrics_header,
    IPv4Header_t encaped_ip_header,
    UDPHeader_t encaped_udp_header
);

/**
 * # Description
 * Set signataure for a given index and block.
 * 
 * # Parameters
 * sig_type (int<<8>>): is this a book signature (==0) or timestamp signature (==1)
 * sig_idx (int<<16>>): index to place signature at
 * block_idx (int<<8>>): block to write too
 * curr_signature (int<<32>>): current signature to write
 * next_signature (int<<32>>): next signature to be written after current is sliced
 *
 * # Generates
 * set_next_signature: set the next signature contained in packet.
 **/
entry event set_signature (
    int<<8>> sig_type,
    int<<16>> sig_idx,
    int<<8>> block_idx,
    int<<32>> curr_signature,
    int<<32>> next_signature
) [
    outgoing_book_signature_manager < outgoing_metric_signature_manager
];

/**
 * # Description
 * Set signataure for a given index and block.
 * 
 * # Parameters
 * sig_type (int<<8>>): is this a book signature (==0) or timestamp signature (==1)
 * sig_idx (int<<16>>): index to place signature at
 * block_idx (int<<8>>): block to write too
 * next_signature (int<<32>>): next signature to be written after current is sliced
 **/
exit event set_next_signature (
    int<<8>> sig_type,
    int<<16>> sig_idx,
    int<<8>> block_idx,
    int<<32>> next_signature
);

/* ================================================================================================================== *
 *                                                    HANDLERS                                                        *
 * ================================================================================================================== */

handle forward_flow (EthernetHeader_t eth_header, IPv4Header_t ip_header, UDPHeader_t udp_header) {

    /* 1. Get metric values. */
    // -- Get updated sequence number
    int<<8>> seq_number = SequenceNumberManager.increment(sequence_counters);

    // -- Get current time in milliseconds
    int<<12>> timestamp = get_time_now_ms();

    /* 2. Sign metric values. */
    // -- Get signature corresponding to sequence number
    int<<1>> book_signature = BookSignatureManager.sign(outgoing_book_signature_manager, seq_number, timestamp[2:2]);

    // -- Get precomputed path-specific signature
    int<<32>> ts_signature = MetricSignatureManager.sign(outgoing_metric_signature_manager, timestamp, timestamp[4:4]);

    // -- get Tango encapsulation
    TangoHeader_t tango_metrics_hdr = {
        path_id = 0;
        timestamp = hash<<16>>(1, timestamp);
        signature = ts_signature;
        sequence_num = (int<<16>>) seq_number;
        book_signature = (int<<8>>) book_signature;
    };

    /* 4. Tunnel packet to peer node. */
    generate_port (
        OUT_PORT,
        incoming_tango_traffic (
            { eth_header with ethertype = 0x86DD },
            { TANGO_V6_HEADER with payload_len = 18 + ip_header#len },
            TANGO_UDP_HEADER,
            tango_metrics_hdr,
            ip_header,
            udp_header
        )
    );
}

handle set_signature (
    int<<8>> sig_type,
    int<<16>> sig_idx,
    int<<8>> block_idx,
    int<<32>> curr_signature,
    int<<32>> next_signature
) {
    if (((int<<32>>) sig_type) == 0) {
        BookSignatureManager.set_signature_word(
            outgoing_book_signature_manager,
            (int<<10>>) sig_idx,
            curr_signature,
            (int<<1>>) block_idx
        );
    } else {
        MetricSignatureManager.set_signature(
            outgoing_metric_signature_manager,
            (int<<4>>) sig_idx,
            curr_signature,
            (int<<1>>) block_idx
        );
    }

    if (next_signature != 0) {
        generate_port(
            RECIRC_PORT,
            set_next_signature(
                sig_type,
                sig_idx,
                block_idx,
                next_signature
            )
        );
    }
}