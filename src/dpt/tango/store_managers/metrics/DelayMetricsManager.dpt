include "../../Types.dpt"
include "../../Time.dpt"

/**
 * # Description
 * Keep track of delay metrics
 * 
 * # Methods
 * create() -> DelayMetricsManager.t
 * update_delay(DelayMetricsManager.t, int, int<<12>>, int<<3>>) -> int<<32>>
 **/
module DelayMetricsManager : {
    global type t;
    constr t create ();

   /**
    * # Description
    * Updates the delay from the incoming Tango packets timestamp
    * 
    * # Parameters
    * self (t): self
    * timestamp (int<<12>>): sequence number to index into pads
    * path_id (int<<3>>): the path on which the packet came
    * 
    * # Returns
    * metrics (int<<32>>): the calculated metrics
    **/
    fun int<<32>> update_delay (
        t self,
        int avg_counter,
        int<<12>> timestamp,
        int<<3>> path_id
    ) [start <= self; end self];

}
{
    type t = {
        Array.t<<32>> delay_sums;
        Array.t<<32>> delay_avgs;
    }

    constr t create() = {
        delay_sums = Array.create(8);
        delay_avgs = Array.create(8);
    };

    /**
     * # Description
     * Update the stored average delay.
     **/
    memop update_delay_avg (
        int<<'sz>> curr_delay_avg,
        int<<'sz>> delay_sum,
        int<<'sz>> curr_count
    ) {
        bool should_reset = curr_count > 62;

        if (should_reset) {
            cell1 = delay_sum;
        }

        if (true) { return cell1; }
    }

    /**
     * # Description
     * Update the stored delay sum.
     **/
    memop get_delay_sum (
        int<<'sz>> curr_delay_sum,
        int<<'sz>> new_delay
    ) {
        return curr_delay_sum + new_delay;
    }

    memop reset_delay_sum (
        int<<'sz>> curr_delay_sum,
        int<<'sz>> new_delay
    ) {
        return 0;
    }


    fun int<<32>> update_delay (
        t self,
        int avg_counter,
        int<<12>> timestamp,
        int<<3>> path_id
    ) {
        // Update and get delay
        int<<12>> curr_time = get_time_now_ms();
        int new_delay = (int<<32>>) (curr_time - timestamp);

        // Update delay sums
        int<<32>> delay_sum = 0;
        if (avg_counter > 62) {
            delay_sum = Array.update(
                self#delay_sums,
                path_id,
                get_delay_sum,
                new_delay,
                reset_delay_sum,
                0
            );
        } else {
            delay_sum = Array.update(
                self#delay_sums,
                path_id,
                get_delay_sum,
                new_delay,
                get_delay_sum,
                new_delay
            );
        }

        // Update average delay
        int<<32>> delay_avg = Array.update_complex(
            self#delay_avgs,
            path_id,
            update_delay_avg,
            delay_sum,
            avg_counter,
            0
        );

        return delay_avg;
    }
}
